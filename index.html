<<!DOCTYPE html>
<html>
<head>
  <link rel="stylesheet" href="index.css"></link>
 </head>
 <body>
    <nav id="navbar">
    <header id="header" style="margin-left: 20px;"><strong>Data Structures</strong></header>
    <ul>
      <li><a class="nav-link" href="#intruduction">Intruduction</a></li>
      <li><a class="nav-link" href="#Characteristics_of_an_Algorithm">Characteristics of an Algorithm</a></li>
      <li><a class="nav-link" href="#How_to_Write_an_Algorithm?">How to Write an Algorithm?</a></li>
      <li><a class="nav-link" href="#Algorithm_Analysis">Algorithm Analysis</a></li>
      <li><a class="nav-link" href="#Algorithm_Complexity">Algorithm Complexity</a></li>
      <li><a class="nav-link" href="#Space_Complexity">Space Complexity</a></li>
      <li><a class="nav-link" href="#if_else_statement">If else statement</a></li>
    </ul>
    </nav>
    <main id="main-doc">
    <header>
<h1>Data Structures & Algorithms</h1>
    </header>
    <section class="main-section" id="intruduction">
  <header id="header">Intruduction</header>
  <article>
    <p>Algorithm is a step-by-step procedure, which defines a set of instructions to be executed in a certain order to get the desired output.
    Algorithms are generally created independent of underlying languages, i.e. an algorithm can be implemented in more than one programming
    language.</p>
    <ul>
      <li><strong>Search</strong> − Algorithm to search an item in a data structure.</li>
      <li><strong>Sort</strong> − Algorithm to sort items in a certain order.</li>
      <li><strong>Update</strong> − Algorithm to update an existing item in a data structure.</li>
      <li><strong>Delete</strong> − Algorithm to delete an existing item from a data structure.</li>
    </ul>
  </article>
</section>

<section class="main-section" id="Characteristics_of_an_Algorithm">
  <header id="header">Characteristics of an Algorithm</header>
<p>Not all procedures can be called an algorithm. An algorithm should have the following characteristics −</p>
<ul>
  <li><strong>Unambiguous</strong> − Algorithm should be clear and unambiguous. Each of its steps (or phases), and their inputs/outputs should be clear and must lead to only one meaning.</li>
  <li><strong>Input</strong> − An algorithm should have 0 or more well-defined inputs.</li>
  <li><strong>Output</strong> − An algorithm should have 1 or more well-defined outputs, and should match the desired output.</li>
  <li><strong>Finiteness</strong> − Algorithms must terminate after a finite number of steps.</li>
  <li><strong>Feasibility</strong> − Should be feasible with the available resources.</li>
  <li><strong>Independent</strong> − An algorithm should have step-by-step directions, which should be independent of any programming code.</li>
</ul>
</section>
<section class="main-section" id="How_to_Write_an_Algorithm?">
  <header id="header">How to Write an Algorithm?</header>
  <p>There are no well-defined standards for writing algorithms. Rather, it is problem and resource dependent. Algorithms are never written to support a particular programming code.

As we know that all programming languages share basic code constructs like loops (do, for, while), flow-control (if-else), etc. These common constructs can be used to write an algorithm.

We write algorithms in a step-by-step manner, but it is not always the case. Algorithm writing is a process and is executed after the problem domain is well-defined. That is, we should know the problem domain, for which we are designing a solution.</p>
</section>

<section class="main-section" id="Algorithm_Analysis">
  <header id="header">Algorithm Analysis</header>
<p>Efficiency of an algorithm can be analyzed at two different stages, before implementation and after implementation. They are the following −</p>
<ul>
  <li><strong>A Priori Analysis</strong> − This is a theoretical analysis of an algorithm. Efficiency of an algorithm is measured by assuming that all other factors, for example, processor speed, are constant and have no effect on the implementation.</li>
 <li><strong>A Posterior Analysis</strong> − This is an empirical analysis of an algorithm. The selected algorithm is implemented using programming language. This is then executed on target computer machine. In this analysis, actual statistics like running time and space required, are collected.</li>
</ul>
<p>We shall learn about a priori algorithm analysis. Algorithm analysis deals with the execution or running time of various operations involved. The running time of an operation can be defined as the number of computer instructions executed per operation.</p>
</section>
<section class="main-section" id="Algorithm_Complexity">
  <header id="header">Algorithm Complexity</header>
<p>Suppose X is an algorithm and n is the size of input data, the time and space used by the algorithm X are the two main factors, which decide the efficiency of X.</p>
<ul>
<li><strong>Time Factor</strong> − Time is measured by counting the number of key operations such as comparisons in the sorting algorithm.</li>
<li><strong>Space Factor</strong> − Space is measured by counting the maximum memory space required by the algorithm.</li>
</ul>
<p>The complexity of an algorithm f(n) gives the running time and/or the storage space required by the algorithm in terms of n as the size of input data.</p>
</section>
<section class="main-section" id="Space_Complexity">
  <header id="header">Space Complexity</header>
  <p>Space complexity of an algorithm represents the amount of memory space required by the algorithm in its life cycle. The space required by an algorithm is equal to the sum of the following two components −</p>
  <ul>
    <li>A fixed part that is a space required to store certain data and variables, that are independent of the size of the problem. For example, simple variables and constants used, program size, etc.</li>
    <li>A variable part is a space required by variables, whose size depends on the size of the problem. For example, dynamic memory allocation, recursion stack space, etc.</li>
  </ul>
  <p>Here we have three variables A, B, and C and one constant. Hence S(P) = 1 + 3. Now, space depends on data types of given variables and constant types and it will be multiplied accordingly.</p>
</section>
<section class="main-section" id="if_else_statement">
<header id="header">If else statement</header>
<p>Use the if statement to execute a statement if a logical condition is true. Use the optional else clause to execute a statement if the condition is false. An if statement looks as follows:</p>
<code>if (condition) { statement_1; } else { statement_2; }</code>
<p>condition can be any expression that evaluates to true or false. See Boolean for an explanation of what evaluates to true and false. If condition evaluates to true, statement_1 is executed; otherwise, statement_2 is executed. statement_1 and statement_2 can be any statement, including further nested if statements.
<br><br>You may also compound the statements using else if to have multiple conditions tested in sequence, as follows:</p>
<code>if (condition_1) { statement_1; } else if (condition_2) { statement_2;
} else if (condition_n) { statement_n; } else { statement_last; }</code>
<p>In the case of multiple conditions only the first logical condition which evaluates to true will be executed. To execute multiple statements, group them within a block statement ({ ... }) . In general, it's good practice to always use block statements, especially when nesting if statements:</p>
<code>if (condition) { statement_1_runs_if_condition_is_true;
statement_2_runs_if_condition_is_true; } else {
statement_3_runs_if_condition_is_false;
statement_4_runs_if_condition_is_false; }
</code>
<p>It is advisable to not use simple assignments in a conditional expression, because the assignment can be confused with equality when glancing over the code. For example, do not use the following code:</p>
<code>if (x = y) { /* statements here */ }</code>
<p>If you need to use an assignment in a conditional expression, a common practice is to put additional parentheses around the assignment. For example:</p>
<code>if ((x = y)) { /* statements here */ }
</code>
<p>A while statement executes its statements as long as a specified condition evaluates to true. A while statement looks as follows:</p>
<code>while (condition) statement</code>
<p>If the condition becomes false, statement within the loop stops executing and control passes to the statement following the loop.</p>
<p>The condition test occurs before statement in the loop is executed. If the condition returns true, statement is executed and the condition is tested again. If the condition returns false, execution stops and control is passed to the statement following while.</p>
</section>
<section>
  <ul><br>
  <li style="padding-bottom: 30px;">All the documentation in this page is taken from
    <a href="https://www.tutorialspoint.com/" target="_blank">Tutotialspoint.</a><br>
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide" target="_blank">MDN</a>
    </li>
  </ul>
</section>
      </main>
      </body>
    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
    </script>
</html>
